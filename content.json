{"pages":[],"posts":[{"title":"逍遥","text":"愿人间走一遭，圆满三界六道，看透是非善恶，从此福来心至，皆是逍遥。","link":"/2020/03/05/my-first-page/"},{"title":"关于清除浮动和BFC","text":"清除浮动 方法 BFC(Block formatting context) 触发BFC的条件 特点和用途 清除浮动#清除浮动的本质：为了解决浮动子元素的父盒子高度为0的问题希望能让内容浮动来撑开父盒子 方法# clear:both浮动盒子后添加一个空标签，给sytle 1&lt;div style=\"clear:both\"&gt;&lt;/div&gt; 父级添加 overflow：hidden/auto因为触发BFC，BFC可清除浮动 after伪元素/双伪元素清除浮动 1234567891011121314151617181920//1.clearFix:after { content:\"\"; display:block; height:0 ; visibility: hidden; clear:both;}//2.clearFix:before, .clearFix:after { content:\"\"; display:block}.clearfix:after { clear:both}.clearfix { *zoom:1 //兼容ie 6 7} BFC(Block formatting context)#块级格式化上下文 独立渲染的区域块级元素 display: block/list-iten/table 触发BFC的条件# float不为none，即浮动元素 position absolute/fixed display的值是inline-block、table-cell、flex、table-caption或者inline-flex overflow的值不是visible(添加BFC常用：一般不会有副作用) 特点和用途# 因为BFC 计算时会计算浮动的盒子的高度所以 常用于 清除浮动 因为同一个BFC的两个相邻的Box会发生margin重叠利用BFC避免margin重叠，如在其中一个盒子外包装多一个div即给新的BFC 因为BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此所以div 封装一个独立的组件的原因 因为BFC的区域不会和浮动的盒子产生交集，会紧贴边缘所以用于自适应 – 自动的适应宽度，这时候就形成了一个两栏自适应的布局。 参考https://blog.csdn.net/sinat_36422236/article/details/88763187","link":"/2020/03/06/css/css-float/"},{"title":"零星的知识点","text":"css html - web存储 cookie Storage js数据类型 symbol 标识值 css#css 三大特性： 层叠： 覆盖作用 继承： 继承字体 文本属性 优先： 多指权重 权重 !important &gt; 行内样式 &gt; id &gt; class &gt; 标签 &gt; 继承样式的权重为0 html - web存储#在客户端存储数据 cookie#由于cookie，不适合大量数据存储，而且它们是由于每个对服务器的请求来传递的，速度慢且效率不高cookie是浏览器提供的一种机制，cookie机制将信息存储于用户硬盘常用于： 保存用户登录状态 跟踪用户行为 Storage#localStorage 没有时间限制 第二天 一周 一年 依旧存在sessionStorage 针对一个session 周期进行数据存储，当用户浏览器关闭，数据会被删除 js数据类型#由于原来的6种+es6 新引入的symbol，现在7种类型了undefined，null boolean， string， number，object，symbol symbol 标识值#es6/菜鸟教程 引入symbol的原因：唯一的标识，如若引入别人提供的对象，又想为对象添加新的方法(mixin模式)，又要防止重名 作为属性名的symbol 不能用 点获取，只能用[]","link":"/2020/03/06/star-knowledge/"},{"title":"关于es6之Set和Map","text":"宏观认识 set weakSet Map weakMap 参考看文档 es6 (http://caibaojian.com/es6/set-map.html) (https://es6.ruanyifeng.com/#docs/symbol) 宏观认识#set#类数组结构 但是成员的值都是唯一的，没有重复的值 123//常用于 做数组去重处理Array.from(new Set(arr))[... new Set(arr)] weakSet#弱引用即垃圾回收机制不考虑WeakSet对该对象的引用也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。作用：暂时缓存 防止内存泄漏 Map#类对象，但是键的类型不限于字符串其实真正的健意义是内存地址绑定的即只要内存地址不一样，就是俩个键，=&gt; 解决了同名内容属性相同碰撞的问题 weakMap#与Map 区别是只 接受对象和null做键名弱引用 应用场景 在网页的Dom元素上添加数据，使用weakMap。但dom被清除了，就没有对象应用weakMap了，而弱引用不会被垃圾回收机制认可为被weakMap引用了，所以对应的weakMAp记录也会被自动移除解决了内存泄漏 部署私用属性类的内部属性用weakMap，若删除实列，他们随之也会消失，不会造成内存泄漏","link":"/2020/03/07/js/es6/es6-Set-Map/"},{"title":"关于作用域和作用域链","text":"概念 关于javaScript 执行和执行上下文 代码实列解析 总: 执行上下文特点 arguments arguments 转数组 arguments 内容展开 执行上下文栈 欺骗词法 eval() 和 with() 概念# 作用域作用：访问 操作 调用域： 区域 空间 范围作用域：代码在程序作用的区域 (1) 全局作用域 --- 全局变量 (2) 局部作用域 --- 局部变量 特点： 隔离变量 作用域链 是js内部一种变量 函数查找的机制，决定变量和函数的作用范围 通俗：一般来说，变量取值是到创建这个变量的函数的作用域中取值 但是如果在当前作用域中没有找到值，就会向上一级作用域去查询直到查到全局作用域， 这么一个查找的过程就形成了链条就叫做作用域 关于javaScript 执行和执行上下文#javaScript 属于解释型语言，分解释阶段和执行阶段 代码编译阶段(解释阶段)：由编译器完成，将代码翻译成可执行代码 词法分析 语法分析 可执行代码生成 作用域规则的确定 代码执行阶段：由引擎完成，主要任务是执行可执行代码 进入执行上下文的生命周期(创建执行上下文) (1)创建阶段 ①创建变量(以此依次为顺序) + 函数环境会初始化创建argument对象(并赋值) + 函数声明(并赋值) + 变量声明，函数表达式声明(未赋值) ②确定this指向 ③建立作用域 (2)执行阶段 变量/对象/函数表达式 赋值 调用函数 顺序这些其他代码 执行函数代码 垃圾回收 概念区分: 执行上下文：说明函数被调用时产生，是在运行时确定，随时可以改变(最明显是this的指向) 执行上下文（执行环境）函数执行前进行的准备工作 如确定作用域，创建局部对象 作用域：在定义时就确认，并且不会改变同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量 代码实列解析#1234567891011121314151617181920212223242526272829303132333435function foo(i){ var a = 'hello' var b = function fun(){ function c(){} }}foo(22);1 当调用函数foo(22)的创建状态如下 2 执行阶段 ExecutionContext = { (执行上下文) scopeChain: {...} (作用域链)变量声明的顺序 variableObject:{1 初始化创建 arguments:{ ---&gt; 同1实参列表arguments 0: 22 0：22(并赋值) length:1 length：1 },2形参并赋值 i:22, ---&gt; 223 函数声明(并赋值) c: pointer to function c(), ---&gt; 同14变量声明(未赋值) a: undefined, ---&gt; hello 变量赋值 b: undefined ---&gt; pointer to function fun() 函数表达式赋值 }, this的指向 this: {...} } ps 关于顺序 1 若函数体内部声明 function i(){}(即形参的同名函数) 会覆盖形参i的声明 (一般不会出现这写法，不规范) 总: 执行上下文特点# 单线程 栈顶的执行上下文执行中，其他需要排队 全局上下文只有一个，处于站底，页面关闭时出栈 函数执行上下文，数量不限，若死循环，递归会堆栈溢出 函数调用时就会创建新的上下文 arguments#js 里一个传递给函数的参数的类数组对象，函数运行时 实参列表执行上下文创建阶段第一步 环境初始化创建arguments arguments 转数组#因为arguments对象不是一个 Array 。它类似于Array，但除了length属性和索引元素之外没有任何Array属性。例如，它没有 pop 方法。但是它可以被转换为一个真正的Array： Array.prototype.slice.call(arguments) Array.from(arguments) arguments 内容展开# 实参 callee： 装了当前正在执行的函数 symbol es6 Symbol类型的键，该类型的值都是独一无二的，该键指向的值是一个values函数 _proto_ 执行上下文栈#执行上下文可以理解为当前代码的执行环境，JavaScript中的运行环境大概包括三种情况： 全局环境：JavaScript代码运行起来会首先进入该环境 函数环境：当函数被调用执行时，会进入当前函数中执行代码 eval 在代码开始执行时，首先会产生一个全局执行上下文环境，调用函数时，会产生函数执行上下文环境，函数调用完成后，它的执行上下文环境以及其中的数据都会被销毁，重新回到全局执行环境，网页关闭后全局执行环境也会销毁。其实这是一个压栈出栈的过程，全局上下文环境永远在栈底，而当前正在执行的函数上下文在栈顶 欺骗词法 eval() 和 with()#JavaScript 中有两种机制来实现：在运行时来“修 改”（也可以说欺骗）词法作用域，欺骗词法作用域会导致性能下降，所以不要使用eval和with。 eval() 函数可以接受一个字符串为参数，对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时） 参考文献 【你不知道的JavaScript】（一）作用域与词法作用域 MDN","link":"/2020/03/10/js/about-scope/"}],"tags":[{"name":"my","slug":"my","link":"/tags/my/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"知识","slug":"知识","link":"/tags/%E7%9F%A5%E8%AF%86/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"概念理解","slug":"概念理解","link":"/tags/%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"}],"categories":[{"name":"css","slug":"css","link":"/categories/css/"},{"name":"html","slug":"html","link":"/categories/html/"},{"name":"js","slug":"js","link":"/categories/js/"}]}